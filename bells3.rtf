{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf320
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue0;\red0\green0\blue191;
\red96\green96\blue96;\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs18 \cf2 ////// functions\cf3 \
(\
\cf2 // map to Dict of Dicts (sfile id, relid)\cf3 \
~mapBy_SF_relID = \{ \cf4 |metadata|\cf3 \
	\cf4 var\cf3  fileMap = \cf4 Dictionary\cf3 [];\
	(metadata.class == \cf4 Dictionary\cf3 []).if\
	\{\
		metadata.keys.asArray.do(\{ \cf4 |unit|\cf3  \
			\cf4 var\cf3  filenum = metadata[unit][1];\
			(fileMap[filenum] == \cf4 nil\cf3 ).if\
			\{\
				fileMap.add(filenum -> \cf4 Dictionary\cf3 [metadata[unit][2] -> metadata[unit]]);\
			\} \{\
				fileMap[filenum].add(metadata[unit][2] -> metadata[unit]);\
			\};\
		\});\
	\} \{	\
		metadata.do(\{ \cf4 |unit|\cf3  \
			\cf4 var\cf3  filenum = unit[1];\
			(fileMap[filenum] == \cf4 nil\cf3 ).if\
			\{\
				fileMap.add(filenum -> \cf4 Dictionary\cf3 [unit[2] -> unit]);\
			\} \{\
				fileMap[filenum].add(unit[2] -> unit);\
			\};\
		\});\
	\};\
	fileMap\
\};\
)\
\
~so = \cf4 Server\cf3 .internal.options;\
~so.device = \cf5 "JackRouter"\cf3 ;\
~so.
\f1 numOutputBusChannels = 2;
\f0 \
\
\cf2 ///////////////////////////\cf3 \
\cf2 // launch server and init + import corpus\cf3 \
\
\cf4 Server\cf3 .default = \cf4 Server\cf3 .internal;\
s = \cf4 Server\cf3 .default.boot;\
~crps = \cf4 CorpusDB\cf3 .new(\cf5 "bells"\cf3 , s);\
\
~crps.importCorpusFromXML(s, \cf5 "/Users/tms/dev/supercollider/bells/xml/bells3.xml"\cf3 )\
~metadata = ~crps.mapSoundFileUnitsToCorpusUnits;\
\
\cf2 // all units, mapped by sfile and rel ids (Dict of Dicts)\cf3 \
~mappedBySF_RelID = ~mapBy_SF_relID.value(~metadata);\
\
\cf2 ////////////////////////////////\cf3 \
\cf2 // set up search\cf3 \
(\
~search3 = \cf4 CorpusSearch\cf3 .new(~crps);\
~search3.buildTree(\cf4 nil\cf3 , [8,9,10,12,15,0], \cf4 true\cf3 , \cf4 true\cf3 );\
\
~nntree = \cf4 Dictionary\cf3 [];\
~search3.normedTree.do(\{ \cf4 |node|\cf3 \
	\cf4 var\cf3  res;\
	[node.label].post; \cf5 ":"\cf3 .postln; \cf2 //, node.location\cf3 \
	~nntree.add(node.label -> \cf4 List\cf3 []);\
	res = ~search3.findNNearest(node.location, 0.3, \cf4 true\cf3 , 7);\
	(res.size > 1).if\
	\{\
		res.do(\{ \cf4 |pair|\cf3 \
			(pair[0].asInteger != node.label.asInteger).if\
			\{\
				~nntree[node.label].add(pair[0].asInteger);\
				pair[0].post; \cf5 " "\cf3 .post;\
			\};\
		\});\
	\} \{\
		~nntree.add(node.label -> \cf4 nil\cf3 );\
		\cf4 nil\cf3 .post;\
	\};\
	\cf5 " "\cf3 .postln;	\
\});\
\
~init_tree = \{\
	~nntree.keysValuesDo(\{ \cf4 |key,val|\cf3  (val != \cf4 nil\cf3 ).if\
		\{\
			(val[1].respondsTo(\cf6 \\sum\cf3 )).if\
			\{\
				~nntree.add(key -> [val[0].asArray, ((val[0].size)..1).collect(\{\cf4 |x|\cf3  2 ** x \}).normalizeSum ]);\
			\} \{\
				~nntree.add(key -> [val.asArray, ((val[0].size)..1).collect(\{\cf4 |x|\cf3  2 ** x \}).normalizeSum ]);\
			\};\
		\} \
	\});\
\};\
)\
~init_tree.value;\
\
\cf2 ////////////////////////////////\cf3 \
\cf2 // set up the freezers and the selection logic\cf3 \
\
\cf2 // read the scpvs\cf3 \
~savedSCPVs = [\cf4 Buffer\cf3 .read(s, \cf5 "/Users/tms/dev/supercollider/bells/fft/buffer0.scpv"\cf3 ), \cf4 Buffer\cf3 .read(s, \cf5 "/Users/tms/dev/supercollider/bells/fft/buffer1.scpv"\cf3 ), \cf4 Buffer\cf3 .read(s, \cf5 "/Users/tms/dev/supercollider/bells/fft/buffer2.scpv"\cf3 ), \cf4 Buffer\cf3 .read(s, \cf5 "/Users/tms/dev/supercollider/bells/fft/buffer3.scpv"\cf3 ), \cf4 Buffer\cf3 .read(s, \cf5 "/Users/tms/dev/supercollider/bells/fft/buffer4.scpv"\cf3 )];\
\
\cf2 //===============================end setup\cf3 \
\
\
\cf2 //////////////////////////////////\cf3 \
\cf2 // iterator(s) + Tdef combinations\cf3 \
\
\cf2 // #7\cf3 \
(\
\cf2 // random swaps + shuffling\cf3 \
~nearestNext = \{ \cf4 |state|\cf3 \
	\cf4 var\cf3  curr, nextcandidates, next, nextindex;\
	\cf2 //state.postln;\cf3 \
	\cf5 "random"\cf3 .postln;\
	curr = ~mappedBySF_RelID[ state.key ][ state.value[0] ][0]; \cf2 // get curr unit id\cf3 \
	nextcandidates = ~nntree[curr];	\
	\cf2 //Post << "before selection + swap" << nextcandidates << Char.nl;\cf3 \
	nextindex = nextcandidates[1].windex;\
	next = nextcandidates[0][nextindex];\
	nextcandidates[0] = nextcandidates[0].swap(nextindex, (nextcandidates[0].size - 1));\
	\cf2 // Post << "after selection + swap" << nextcandidates << Char.nl;\cf3 \
	\cf2 // Post << "selection: " << next << Char.nl;\cf3 \
	next\
\};\
)\
\
\cf2 // Tdef\cf3 \
(\
\cf4 Tdef\cf3 (\cf6 \\meta\cf3 , \{ \cf4 |event, startUnit=0, sf=4|\cf3  \cf2 // set only on init or reset!\cf3 \
	\cf4 var\cf3  currentUnit, currentSFileState, currentSynth, theunits = ~mappedBySF_RelID[4].keys.asArray.sort;\
	\cf4 var\cf3  dur, pwidth;\
	\cf2 //rotate theunits to startunit\cf3 \
\
	currentSFileState = (sf -> theunits);\
	currentSFileState.postln;\
	currentUnit = ~mappedBySF_RelID[ sf ][ theunits[0] ];\
\
	\cf5 "loop"\cf3 .postln;\
	theunits.size.do(\{\
		dur = (currentUnit[4] * 0.001);\
		pwidth = 1.0.linrand;\
		\
		(0.7.coin).if\
		\{\
			(0.4.coin).if\
			\{\
				\cf5 "SA"\cf3 .postln;\
				currentSynth = \cf4 Synth\cf3 (\cf6 \\unitSamplerS\cf3 , [\
					\cf6 \\bufNumL\cf3 , ~crps[\cf6 \\sftable\cf3 ][ ~crps[\cf6 \\sfmap\cf3 ][ currentUnit[1] ] ][\cf6 \\bfrL\cf3 ] ,\
					\cf6 \\bufNumR\cf3 , ~crps[\cf6 \\sftable\cf3 ][ ~crps[\cf6 \\sfmap\cf3 ][ currentUnit[1] ] ][\cf6 \\bfrR\cf3 ],\
					\cf6 \\offset\cf3 , (currentUnit[3] * 0.001),\
					\cf6 \\dur\cf3 , dur,\
					\cf6 \\panL\cf3 , (pwidth.sqrt * -1), \cf6 \\panR\cf3 , pwidth.sqrt,\
					\cf6 \\attack\cf3 , 0.05, \cf6 \\release\cf3 , 0.05,\
					\cf6 \\da\cf3 , 2\
				]);\
			\} \{\
				(0.25.coin).if\
				\{\
					\cf5 "SD"\cf3 .postln;\
						currentSynth = \cf4 Synth\cf3 (\cf6 \\unitSamplerSD\cf3 , [\
						\cf6 \\bufNumL\cf3 , ~crps[\cf6 \\sftable\cf3 ][ ~crps[\cf6 \\sfmap\cf3 ][ currentUnit[1] ] ][\cf6 \\bfrL\cf3 ] ,\
						\cf6 \\bufNumR\cf3 , ~crps[\cf6 \\sftable\cf3 ][ ~crps[\cf6 \\sfmap\cf3 ][ currentUnit[1] ] ][\cf6 \\bfrR\cf3 ],\
						\cf6 \\offset\cf3 , (currentUnit[3] * 0.001),\
						\cf6 \\dur\cf3 , dur,\
						\cf6 \\panL\cf3 , (pwidth * -1), \cf6 \\panR\cf3 , pwidth,\
						\cf6 \\attack\cf3 , 0.05, \cf6 \\release\cf3 , 0.05,\
						\cf6 \\da\cf3 , 2\
					]);\
				\} \{\
					\cf5 "SA"\cf3 .postln;\
					currentSynth = \cf4 Synth\cf3 (\cf6 \\unitSamplerSA\cf3 , [\
						\cf6 \\bufNumL\cf3 , ~crps[\cf6 \\sftable\cf3 ][ ~crps[\cf6 \\sfmap\cf3 ][ currentUnit[1] ] ][\cf6 \\bfrL\cf3 ] ,\
						\cf6 \\bufNumR\cf3 , ~crps[\cf6 \\sftable\cf3 ][ ~crps[\cf6 \\sfmap\cf3 ][ currentUnit[1] ] ][\cf6 \\bfrR\cf3 ],\
						\cf6 \\offset\cf3 , (currentUnit[3] * 0.001),\
						\cf6 \\dur\cf3 , dur,\
						\cf6 \\panL\cf3 , (pwidth ** 2) * -1, \cf6 \\panR\cf3 , pwidth ** 2,\
						\cf6 \\attack\cf3 , 0.05, \cf6 \\release\cf3 , 0.05,\
						\cf6 \\da\cf3 , 2,\
						\cf6 \\freq\cf3 , currentUnit[5]\
					]);\
				\};\
			\};\
		\} \{\
			\cf2 // silence\cf3 \
			\cf5 "silent"\cf3 .postln;\
		\};\
		\
		(dur + (exprand(0.001, (dur * 0.25)) * [1].choose)).postln;\
		(dur + (exprand(0.001, (dur * 0.25)) * [1].choose)).wait;\
\
		\cf2 // get next unit\cf3 \
		currentSFileState.value = currentSFileState.value.rotate(-1);\
		(0.3.coin).if\
		\{\
			currentUnit = ~nearestNext.value(currentSFileState);\
			currentUnit = ~crps[\cf6 \\cutable\cf3 ][currentUnit];\
		\} \{\
			currentUnit = ~mappedBySF_RelID[ sf ][ currentSFileState.value[0] ];\
		\};\
	\});\
	\cf5 "done"\cf3 .postln;\
\});\
\
)\
\
\cf4 Tdef\cf3 (\cf6 \\meta\cf3 ).reset;\
\cf2 //~init_tree.value;\cf3 \
\
\cf4 Tdef\cf3 (\cf6 \\meta\cf3 ).play;\
\cf4 Tdef\cf3 (\cf6 \\meta\cf3 ).stop;\
\
\
\
\cf2 //////////////////////////////////\cf3 \
\cf2 // iterator(s) + Tdef combinations\cf3 \
\
\cf2 // #8\cf3 \
(\
\cf2 // random swaps + shuffling\cf3 \
~nearestNext = \{ \cf4 |state|\cf3 \
	\cf4 var\cf3  curr, nextcandidates, next, nextindex;\
	\cf2 //state.postln;\cf3 \
	\cf5 "random"\cf3 .postln;\
	curr = ~mappedBySF_RelID[ state.key ][ state.value[0] ][0]; \cf2 // get curr unit id\cf3 \
	nextcandidates = ~nntree[curr];	\
	\cf2 //Post << "before selection + swap" << nextcandidates << Char.nl;\cf3 \
	nextindex = nextcandidates[1].windex;\
	next = nextcandidates[0][nextindex];\
	nextcandidates[0] = nextcandidates[0].swap(nextindex, (nextcandidates[0].size - 1));\
	\cf2 // Post << "after selection + swap" << nextcandidates << Char.nl;\cf3 \
	\cf2 // Post << "selection: " << next << Char.nl;\cf3 \
	next\
\};\
)\
\
\cf2 // Tdef\cf3 \
(\
\cf4 Tdef\cf3 (\cf6 \\meta2\cf3 , \{ \cf4 |event, startUnit=0, sf=4, baserate=0.075|\cf3  \cf2 // set only on init or reset!\cf3 \
	\cf4 var\cf3  currentUnit, currentSFileState, currentSynth, theunits = ~mappedBySF_RelID[sf].keys.asArray.sort;\
	\cf4 var\cf3  rate, dur, pwidth;\
	\cf2 //rotate theunits to startunit\cf3 \
\
	currentSFileState = (sf -> theunits);\
	currentSFileState.postln;\
	currentUnit = ~mappedBySF_RelID[ sf ][ theunits[0] ];\
\
	\cf5 "loop"\cf3 .postln;\
	theunits.size.do(\{\
		rate = baserate;\
		dur = (currentUnit[4] * 0.001);\
		pwidth = 1.0.linrand;\
		\
		rate.postln;\
		\
		(0.9.coin).if\
		\{\
			(0.3.coin).if\
			\{\
				\cf5 "play"\cf3 .postln;\
				currentSynth = \cf4 Synth\cf3 (\cf6 \\pvplay\cf3 , [\
					\cf6 \\pBuf\cf3 , ~savedSCPVs[currentUnit[1]] ,\
					\cf6 \\rate\cf3 , rate,\
					\cf6 \\foffset\cf3 , ((currentUnit[3] * 44.1) / 512).floor,\
					\cf6 \\dur\cf3 , (dur / rate),\
					\cf6 \\pan\cf3 , pwidth * [-1,1].choose,\
					\cf6 \\atk\cf3 , 0.5, \cf6 \\rel\cf3 , 0.5\
				]);\
			\} \{\
				(0.5.coin).if\
				\{\
					\cf5 "C"\cf3 .postln;\
					currentSynth = \cf4 Synth\cf3 (\cf6 \\pvplayC\cf3 , [\
						\cf6 \\pBuf\cf3 , ~savedSCPVs[currentUnit[1]] ,\
						\cf6 \\rate\cf3 , rate,\
						\cf6 \\foffset\cf3 , ((currentUnit[3] * 44.1) / 512).floor,\
						\cf6 \\dur\cf3 , (dur / rate),\
						\cf6 \\pan\cf3 , pwidth * [-1,1].choose,\
						\cf6 \\atk\cf3 , 0.5, \cf6 \\rel\cf3 , 0.5,\
						\cf6 \\freq\cf3 , currentUnit[5]\
					]);\
				\} \{\
					\cf5 "MS"\cf3 .postln;\
					currentSynth = \cf4 Synth\cf3 (\cf6 \\pvplayMS\cf3 , [\
						\cf6 \\pBuf\cf3 , ~savedSCPVs[currentUnit[1]] ,\
						\cf6 \\rate\cf3 , rate,\
						\cf6 \\foffset\cf3 , ((currentUnit[3] * 44.1) / 512).floor,\
						\cf6 \\dur\cf3 , (dur / rate),\
						\cf6 \\pan\cf3 , pwidth * [-1,1].choose,\
						\cf6 \\atk\cf3 , 0.5, \cf6 \\rel\cf3 , 0.5,\
						\cf6 \\freq\cf3 , currentUnit[5]\
\
					]);\
				\};\
			\};\
		\} \{\
			\cf2 // silence\cf3 \
			\cf5 "silent"\cf3 .postln;\
		\};\
		\
		\cf2 //(dur + (exprand(0.001, (dur * 0.25)) * [1].choose)).postln;\cf3 \
		(((dur - exprand(0.001, (dur * 0.25))) / rate) - 0.5).postln;\
		(\cf0 ((dur - exprand(0.001, (dur * 0.25))) / rate) - 0.5\cf3 ).wait;\
\
		\cf2 // get next unit\cf3 \
		currentSFileState.value = currentSFileState.value.rotate(-1);\
		(0.3.coin).if\
		\{\
			currentUnit = ~nearestNext.value(currentSFileState);\
			currentUnit = ~crps[\cf6 \\cutable\cf3 ][currentUnit];\
		\} \{\
			currentUnit = ~mappedBySF_RelID[ sf ][ currentSFileState.value[0] ];\
		\};\
	\});\
	\cf5 "done"\cf3 .postln;\
\});\
\
)\
\
\cf4 Tdef\cf3 (\cf6 \\meta2\cf3 ).reset;\
\cf2 //~init_tree.value;\cf3 \
\
\cf4 Tdef\cf3 (\cf6 \\meta2\cf3 ).play;\
\cf4 Tdef\cf3 (\cf6 \\meta2\cf3 ).stop;}